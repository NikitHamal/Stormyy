<!DOCTYPE html>

<html>

<head>
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      perspective: 1000px;
      font-family: 'Poppins', sans-serif;
    }

    .orb-container {
      position: relative;
      width: 200px;
      height: 200px;
      transform-style: preserve-3d;
    }

    .magical-orb {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      animation: float 4s ease-in-out infinite;
    }

    .orb-inner {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, 
        rgb(147, 51, 234),
        rgb(88, 28, 135));
      box-shadow: 0 0 60px rgba(147, 51, 234, 0.4);
      transform-style: preserve-3d;
      animation: pulse 2s ease-in-out infinite;
      transition: background 0.3s, box-shadow 0.3s;
    }
    .data-stream {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: 
        radial-gradient(circle at center, 
          transparent 30%, 
          rgba(0, 255, 255, 0.1) 70%,
          transparent 71%
        );
      animation: dataStream 5s linear infinite;
      transform-style: preserve-3d;
    }

    .energy-ring {
      position: absolute;
      width: 120%;
      height: 120%;
      top: -10%;
      left: -10%;
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 255, 0.3);
      animation: energyRing 6s ease-in-out infinite;
      transform-style: preserve-3d;
    }

    .thunder-wave {
      position: absolute;
      width: 140%;
      height: 140%;
      top: -20%;
      left: -20%;
      border-radius: 50%;
      background: 
        repeating-radial-gradient(
          circle at center,
          transparent 0%,
          rgba(147, 51, 234, 0.1) 2%,
          rgba(167, 71, 254, 0.2) 3%,
          transparent 4%
        );
      filter: blur(1px);
      animation: thunderWave 3s linear infinite;
      mix-blend-mode: screen;
    }

    .eyes-container {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 2;
      animation: eyesFloat 4s ease-in-out infinite;
    }

    .eye {
      position: absolute;
      width: 30px;
      height: 30px;
      background: white;
      border-radius: 50%;
      top: 35%;
      animation: blink 4s infinite;
      overflow: hidden;
      transition: transform 0.3s ease-out;
    }

    .eye-left {
      left: 25%;
    }

    .eye-right {
      right: 25%;
    }

    .pupil {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #000;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: lookAround 8s infinite;
    }

    @keyframes thunderWave {
      0% {
        transform: scale(0.8) rotate(0deg);
        opacity: 0.3;
      }
      50% {
        transform: scale(1.2) rotate(180deg);
        opacity: 0.8;
      }
      100% {
        transform: scale(0.8) rotate(360deg);
        opacity: 0.3;
      }
    }

    @keyframes float {
      0%, 100% { transform: translateY(-10px); }
      50% { transform: translateY(10px); }
    }

    @keyframes blink {
      0%, 48%, 52%, 100% { transform: scaleY(1); }
      50% { transform: scaleY(0.1); }
    }

    @keyframes lookAround {
      0%, 100% { transform: translate(-50%, -50%); }
      15% { transform: translate(-100%, -50%); }
      30% { transform: translate(-50%, -100%); }
      45% { transform: translate(0%, -50%); }
      60% { transform: translate(-50%, 0%); }
      75% { transform: translate(-50%, -50%); }
    }

    @keyframes eyesFloat {
      0%, 100% { transform: translateY(-5px); }
      50% { transform: translateY(5px); }
    }

    /* Add new chat interface styles */
    .chat-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      background: rgba(147, 51, 234, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 15px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-out;
      z-index: 1000;
    }

    .chat-container.visible {
      opacity: 1;
      pointer-events: all;
    }

    .input-group {
      display: flex;
      gap: 10px;
    }

    .chat-input {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 15px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 16px;
      transition: background 0.3s;
    }

    .chat-input:focus {
      background: rgba(0, 0, 0, 0.9);
      outline: none;
    }

    .send-button {
      padding: 12px 20px;
      border: none;
      border-radius: 15px;
      background: rgb(147, 51, 234);
      color: white;
      cursor: pointer;
      transition: all 0.3s;
    }

    .send-button:hover {
      background: rgb(167, 71, 254);
    }

    /* New animations */
    @keyframes thinking {
      0% { transform: rotate(0deg) scale(1) translateY(0px); }
      25% { transform: rotate(5deg) scale(1.1) translateY(-5px); }
      75% { transform: rotate(-5deg) scale(0.9) translateY(5px); }
      100% { transform: rotate(0deg) scale(1) translateY(0px); }
    }

    .thinking .magical-orb {
      animation: thinking 1.5s ease-in-out infinite !important;
    }

    .thinking .thunder-wave {
      animation: thunderWave 2s linear infinite;
      opacity: 0.8;
    }

    .response-received .orb-inner {
      animation: pulse 1s ease-in-out;
      box-shadow: 0 0 100px rgba(147, 51, 234, 0.8);
    }

    /* Add these new styles after the existing styles */
    .speech-bubble {
      position: absolute;
      top: -80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(147, 51, 234, 0.3);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 20px;
      max-width: 300px;
      min-width: 150px;
      color: white;
      font-size: 14px;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
      z-index: 1000;
      text-align: center;
      box-shadow: 0 0 20px rgba(147, 51, 234, 0.2);
      display: block;
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 12px solid rgba(147, 51, 234, 0.3);
    }

    .speech-bubble.active {
      opacity: 1;
      top: -100px;
      transform: translateX(-50%) scale(1);
      visibility: visible;
    }

    .speech-bubble.thinking {
      content: 'Thinking...';
    }

    .thinking-dots {
      display: none;
      justify-content: center;
      gap: 4px;
      margin-top: 10px;
    }

    .dot {
      width: 8px;
      height: 8px;
      background: rgb(147, 51, 234);
      border-radius: 50%;
      opacity: 0.6;
    }

    .thinking .thinking-dots {
      display: flex;
    }

    .thinking .dot {
      animation: dotPulse 1.4s infinite;
    }

    .thinking .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .thinking .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes dotPulse {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.5); opacity: 1; }
    }

    /* Click animation for the orb */
    @keyframes clickPulse {
      0% { transform: scale(1); }
      50% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .orb-click {
      animation: clickPulse 0.3s ease-out;
    }

    /* Enhance existing animations */
    @keyframes thinking {
      0% { 
        transform: rotate(0deg) scale(1) translateY(0px);
        filter: brightness(1);
      }
      25% { 
        transform: rotate(5deg) scale(1.1) translateY(-5px);
        filter: brightness(1.2);
      }
      75% { 
        transform: rotate(-5deg) scale(0.9) translateY(5px);
        filter: brightness(0.9);
      }
      100% { 
        transform: rotate(0deg) scale(1) translateY(0px);
        filter: brightness(1);
      }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .orb-container {
        width: 150px;
        height: 150px;
      }

      .chat-container {
        width: 90%;
        max-width: 400px;
      }

      .speech-bubble {
        width: 80%;
        max-width: 300px;
        font-size: 12px;
      }

      .eye {
        width: 25px;
        height: 25px;
      }

      .pupil {
        width: 10px;
        height: 10px;
      }
    }

    @media (max-width: 480px) {
      .orb-container {
        width: 120px;
        height: 120px;
      }

      .chat-container {
        padding: 10px;
      }

      .chat-input {
        font-size: 14px;
      }

      .send-button {
        padding: 8px 15px;
      }
    }

    /* Add new chat history styles */
    .chat-history {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      display: none;
    }

    .chat-message {
      margin: 8px 0;
      padding: 8px 12px;
      border-radius: 12px;
      max-width: 80%;
    }

    .user-message {
      background: rgba(147, 51, 234, 0.3);
      margin-left: auto;
      color: white;
    }

    .bot-message {
      background: rgba(255, 255, 255, 0.1);
      margin-right: auto;
      color: white;
    }

    .chat-container.expanded .chat-history {
      display: block;
    }

    /* Add these styles to the existing <style> section */
    .chat-history-icon {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(147, 51, 234, 0.2);
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.3s, background 0.3s;
      z-index: 1000;
    }

    .chat-history-icon:hover {
      transform: scale(1.1);
      background: rgba(147, 51, 234, 0.3);
    }

    .chat-history-icon svg {
      width: 24px;
      height: 24px;
      fill: white;
    }

    /* Remove the chat history styles */
    .chat-history {
      display: none;
    }

    /* Add idle message style */
    .idle-message {
      position: absolute;
      top: -60px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      text-align: center;
      pointer-events: none;
    }

    .idle-message.visible {
      opacity: 1;
    }

    /* Add a subtle glow effect when visible */
    .chat-container.visible .input-group {
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Add microphone icon styles */
    .mic-icon {
      position: absolute;
      right: 60px;
      top: 50%;
      transform: translateY(-50%);
      width: 24px;
      height: 24px;
      cursor: pointer;
      fill: white;
      opacity: 0.7;
      transition: opacity 0.3s;
    }

    .mic-icon:hover {
      opacity: 1;
    }

    .mic-icon.listening {
      animation: pulseRed 1.5s infinite;
    }

    @keyframes pulseRed {
      0% { fill: white; }
      50% { fill: #ff4444; }
      100% { fill: white; }
    }

    /* Remove the mic-icon styles and add orb listening state styles */
    .orb-container.listening .magical-orb {
      animation: listeningPulse 1.5s infinite !important;
    }

    .orb-container.listening .thunder-wave {
      animation: thunderWave 1.5s linear infinite;
      opacity: 0.9;
      filter: hue-rotate(45deg);
    }

    @keyframes listeningPulse {
      0% { transform: scale(1); filter: brightness(1); }
      50% { transform: scale(1.05); filter: brightness(1.2); }
      100% { transform: scale(1); filter: brightness(1); }
    }

    /* Update speech bubble styles for listening state */
    .speech-bubble.listening {
      background: rgba(255, 68, 68, 0.3);
    }

    .speech-bubble.listening::after {
      border-top-color: rgba(255, 68, 68, 0.3);
    }

    /* Add these styles for the keyboard icon */
    .keyboard-icon {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      background: rgba(147, 51, 234, 0.2);
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.3s, background 0.3s;
      z-index: 1000;
    }

    .keyboard-icon:hover {
      transform: scale(1.1);
      background: rgba(147, 51, 234, 0.3);
    }

    .keyboard-icon svg {
      width: 24px;
      height: 24px;
      fill: white;
    }

    .keyboard-icon.active {
      background: rgba(147, 51, 234, 0.4);
      transform: scale(0.95);
    }
    .caption-container {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(147, 51, 234, 0.2);
      padding: 8px 16px;
      border-radius: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .caption-text {
      color: white;
      font-size: 14px;
      text-align: center;
    }

    /* Add emotion styles with !important to override default state */
    .orb-container[data-emotion="happy"] .orb-inner {
      background: radial-gradient(circle at 30% 30%, 
        rgb(255, 189, 89),
        rgb(255, 145, 48)) !important;
      box-shadow: 0 0 60px rgba(255, 166, 0, 0.4) !important;
    }

    .orb-container[data-emotion="sad"] .orb-inner {
      background: radial-gradient(circle at 30% 30%, 
        rgb(100, 181, 246),
        rgb(30, 136, 229)) !important;
      box-shadow: 0 0 60px rgba(30, 136, 229, 0.4) !important;
    }

    .orb-container[data-emotion="angry"] .orb-inner {
      background: radial-gradient(circle at 30% 30%, 
        rgb(255, 82, 82),
        rgb(211, 47, 47)) !important;
      box-shadow: 0 0 60px rgba(211, 47, 47, 0.4) !important;
    }

    .orb-container[data-emotion="confused"] .orb-inner {
      background: radial-gradient(circle at 30% 30%, 
        rgb(171, 71, 188),
        rgb(142, 36, 170)) !important;
      box-shadow: 0 0 60px rgba(142, 36, 170, 0.4) !important;
    }

    /* Update eye styles to handle emotions */
    .eye {
      position: absolute;
      width: 30px;
      height: 30px;
      background: white;
      border-radius: 50%;
      top: 35%;
      animation: blink 4s infinite;
      overflow: hidden;
      transition: transform 0.3s ease-out;
    }

    /* Add emotion-specific eye animations with !important */
    .orb-container[data-emotion="happy"] .eye {
      transform: scale(1.1) translateY(-2px) !important;
    }

    .orb-container[data-emotion="sad"] .eye {
      transform: scale(0.9) translateY(2px) !important;
    }

    .orb-container[data-emotion="angry"] .eye {
      transform: scaleY(0.8) !important;
    }

    .orb-container[data-emotion="confused"] .eye-left {
      transform: translateY(-2px) !important;
    }

    .orb-container[data-emotion="confused"] .eye-right {
      transform: translateY(2px) !important;
    }

    /* Add these emotion-specific animations */
    @keyframes happyBounce {
      0%, 100% { transform: translateY(-10px) scale(1); }
      50% { transform: translateY(10px) scale(1.1); }
    }

    @keyframes sadDroop {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(15px) scale(0.95); }
    }

    @keyframes angryShake {
      0%, 100% { transform: translateX(0) scale(1); }
      25% { transform: translateX(-5px) scale(1.05); }
      75% { transform: translateX(5px) scale(1.05); }
    }

    @keyframes confusedSpin {
      0% { transform: rotate(-5deg) scale(1); }
      50% { transform: rotate(5deg) scale(0.95); }
      100% { transform: rotate(-5deg) scale(1); }
    }

    /* Add thunder effects for angry state */
    @keyframes angryThunder {
      0% { opacity: 0.3; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1.3); }
      51% { opacity: 0.3; transform: scale(0.8); }
      100% { opacity: 0.3; transform: scale(0.8); }
    }

    /* Update emotion styles with animations */
    .orb-container[data-emotion="happy"] .magical-orb {
      animation: happyBounce 2s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="happy"] .thunder-wave {
      opacity: 0.6;
      filter: hue-rotate(280deg) brightness(1.5);
    }

    .orb-container[data-emotion="sad"] .magical-orb {
      animation: sadDroop 3s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="sad"] .thunder-wave {
      opacity: 0.3;
      filter: hue-rotate(180deg);
    }

    .orb-container[data-emotion="angry"] .magical-orb {
      animation: angryShake 0.5s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="angry"] .thunder-wave {
      animation: angryThunder 1s linear infinite !important;
      filter: hue-rotate(320deg) brightness(1.5);
    }

    .orb-container[data-emotion="confused"] .magical-orb {
      animation: confusedSpin 3s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="confused"] .thunder-wave {
      animation: thunderWave 4s linear infinite reverse;
      filter: hue-rotate(90deg);
    }

    /* Add particle effects for emotional states */
    .emotion-particles {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .orb-container[data-emotion] .emotion-particles {
      opacity: 1;
    }

    @keyframes particleFloat {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-50px) scale(0); opacity: 0; }
    }

    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: particleFloat 2s ease-out forwards;
    }

    /* Add this to the existing eye animations */
    .orb-container[data-emotion="happy"] .pupil {
      animation: happyPupils 3s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="sad"] .pupil {
      animation: sadPupils 3s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="angry"] .pupil {
      animation: angryPupils 1s ease-in-out infinite !important;
    }

    .orb-container[data-emotion="confused"] .pupil {
      animation: confusedPupils 3s linear infinite !important;
    }

    @keyframes happyPupils {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }

    @keyframes sadPupils {
      0%, 100% { transform: translate(-50%, -50%); }
      50% { transform: translate(-50%, 0%); }
    }

    @keyframes angryPupils {
      0%, 100% { transform: translate(-50%, -50%) scaleY(0.8); }
      50% { transform: translate(-50%, -50%) scaleY(1.2); }
    }

    @keyframes confusedPupils {
      0% { transform: translate(-100%, -50%); }
      25% { transform: translate(-50%, -100%); }
      50% { transform: translate(0%, -50%); }
      75% { transform: translate(-50%, 0%); }
      100% { transform: translate(-100%, -50%); }
    }

    /* Thunderbolt icon styles */
    .thunderbolt-icon {
      position: fixed;
      top: 20px;
      left: 80px; /* Position it next to keyboard icon */
      width: 50px;
      height: 50px;
      background: rgba(255, 215, 0, 0.2);
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.3s, background 0.3s;
      z-index: 1000;
    }

    .thunderbolt-icon:hover {
      transform: scale(1.1);
      background: rgba(255, 215, 0, 0.3);
    }

    .thunderbolt-icon svg {
      width: 24px;
      height: 24px;
      fill: #FFD700;
    }

    .thunderbolt-icon.active {
      background: rgba(255, 215, 0, 0.4);
      transform: scale(0.95);
    }

    /* Lightning effect styles */
    .lightning-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      z-index: 10;
    }

    .lightning-effect.active {
      animation: lightningFlash 0.5s ease-out;
    }

    @keyframes lightningFlash {
      0% {
        opacity: 0;
      }
      25% {
        opacity: 1;
        background: linear-gradient(45deg, 
          rgba(255, 255, 255, 0.8),
          rgba(255, 215, 0, 0.8)
        );
      }
      50% {
        opacity: 0;
      }
      75% {
        opacity: 1;
        background: linear-gradient(-45deg,
          rgba(255, 255, 255, 0.6),
          rgba(255, 215, 0, 0.6)
        );
      }
      100% {
        opacity: 0;
      }
    }

    /* Hurt animation styles */
    @keyframes hurtShake {
      0%, 100% { transform: translate(0, 0) scale(1); }
      25% { transform: translate(-10px, 5px) scale(0.95); }
      50% { transform: translate(8px, -4px) scale(0.97); }
      75% { transform: translate(-6px, 3px) scale(0.98); }
    }

    @keyframes hurtEyes {
      0%, 100% { transform: scaleY(1); }
      50% { transform: scaleY(0.2); }
    }

    .orb-container.hurt .magical-orb {
      animation: hurtShake 0.5s ease-out !important;
    }

    .orb-container.hurt .eye {
      animation: hurtEyes 0.5s ease-out !important;
    }

    .orb-container.hurt .thunder-wave {
      animation: thunderWave 0.5s linear infinite !important;
      opacity: 1 !important;
      filter: hue-rotate(180deg) brightness(1.5) !important;
    }

    /* Add hurt state styles */
    .orb-container.hurt .orb-inner {
      background: radial-gradient(circle at 30% 30%, 
        rgb(255, 165, 0),
        rgb(255, 69, 0)) !important;
      box-shadow: 0 0 60px rgba(255, 69, 0, 0.6) !important;
    }

    /* Add these new icon styles */
    .tickle-icon, .love-icon, .dizzy-icon {
      position: fixed;
      width: 50px;
      height: 50px;
      background: rgba(147, 51, 234, 0.2);
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.3s, background 0.3s;
      z-index: 1000;
    }

    .tickle-icon {
      top: 20px;
      left: 140px;
      background: rgba(255, 182, 193, 0.2);
    }

    .love-icon {
      top: 20px;
      left: 200px;
      background: rgba(255, 105, 180, 0.2);
    }

    .dizzy-icon {
      top: 20px;
      left: 260px;
      background: rgba(138, 43, 226, 0.2);
    }

    .tickle-icon:hover, .love-icon:hover, .dizzy-icon:hover {
      transform: scale(1.1);
    }

    .tickle-icon svg, .love-icon svg, .dizzy-icon svg {
      width: 24px;
      height: 24px;
      fill: white;
    }

    /* Add new animation keyframes */
    @keyframes tickle {
      0%, 100% { transform: rotate(0) scale(1); }
      25% { transform: rotate(15deg) scale(1.1); }
      50% { transform: rotate(-15deg) scale(0.9); }
      75% { transform: rotate(10deg) scale(1.05); }
    }

    @keyframes love {
      0% { transform: scale(1); }
      25% { transform: scale(1.2); }
      50% { transform: scale(0.95); }
      75% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    @keyframes dizzy {
      0% { transform: rotate(0) scale(1); }
      100% { transform: rotate(360deg) scale(1); }
    }

    @keyframes heartBeat {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0; }
      100% { transform: scale(2); opacity: 0; }
    }

    /* Add heart particles style */
    .heart-particle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: pink;
      clip-path: path('M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z');
      animation: heartBeat 1s forwards;
    }

    /* Add stars for dizzy effect */
    .star-particle {
      position: absolute;
      width: 15px;
      height: 15px;
      background: yellow;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: starSpin 1s linear infinite;
    }

    @keyframes starSpin {
      0% { transform: rotate(0) scale(1); opacity: 1; }
      100% { transform: rotate(360deg) scale(0); opacity: 0; }
    }

    /* Add dizzy eyes animation */
    @keyframes dizzyEyes {
      0% { transform: rotate(0) translateX(0); }
      100% { transform: rotate(360deg) translateX(5px); }
    }

    .orb-container.dizzy .pupil {
      animation: dizzyEyes 0.5s linear infinite !important;
    }

    /* Add tickle eyes animation */
    @keyframes tickleEyes {
      0%, 100% { transform: translate(-50%, -50%); }
      25% { transform: translate(-30%, -60%); }
      50% { transform: translate(-70%, -40%); }
      75% { transform: translate(-40%, -30%); }
    }

    .orb-container.tickled .pupil {
      animation: tickleEyes 0.3s linear infinite !important;
    }

    /* Add love eyes animation */
    @keyframes loveEyes {
      0%, 100% { clip-path: none; background: white; }
      50% { 
        clip-path: path('M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z');
        background: pink;
      }
    }

    .orb-container.loved .eye {
      animation: loveEyes 0.5s ease-in-out infinite !important;
    }

    /* Add these new interaction icons */
    .sleep-icon, .party-icon, .sneeze-icon {
      position: fixed;
      width: 50px;
      height: 50px;
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform 0.3s, background 0.3s;
      z-index: 1000;
    }

    .sleep-icon {
      top: 20px;
      left: 320px;
      background: rgba(70, 130, 180, 0.2);
    }

    .party-icon {
      top: 20px;
      left: 380px;
      background: rgba(255, 69, 0, 0.2);
    }

    .sneeze-icon {
      top: 20px;
      left: 440px;
      background: rgba(144, 238, 144, 0.2);
    }

    /* Add new animations */
    @keyframes sleep {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(5px); }
    }

    @keyframes snore {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes party {
      0% { transform: rotate(0) scale(1); filter: hue-rotate(0deg); }
      25% { transform: rotate(15deg) scale(1.1); filter: hue-rotate(90deg); }
      50% { transform: rotate(-15deg) scale(0.9); filter: hue-rotate(180deg); }
      75% { transform: rotate(10deg) scale(1.05); filter: hue-rotate(270deg); }
      100% { transform: rotate(0) scale(1); filter: hue-rotate(360deg); }
    }

    @keyframes sneeze {
      0% { transform: scale(1) rotate(0); }
      25% { transform: scale(1.1) rotate(-5deg); }
      50% { transform: scale(0.9) rotate(5deg); }
      75% { transform: scale(1.2) rotate(-10deg); }
      90% { transform: scale(0.8) rotate(10deg); }
      100% { transform: scale(1) rotate(0); }
    }

    /* Add sleeping Z's animation */
    @keyframes floatingZ {
      0% { transform: translate(0, 0) rotate(0) scale(1); opacity: 1; }
      100% { transform: translate(-50px, -50px) rotate(20deg) scale(0); opacity: 0; }
    }

    .z-particle {
      position: absolute;
      font-family: 'Arial', sans-serif;
      font-size: 24px;
      font-weight: bold;
      color: rgba(70, 130, 180, 0.8);
      animation: floatingZ 2s ease-out forwards;
    }

    /* Add party confetti */
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confettiFall 3s linear forwards;
    }

    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0) scale(1); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg) scale(0); opacity: 0; }
    }

    /* Add sneeze particles */
    .sneeze-droplet {
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(144, 238, 144, 0.6);
      border-radius: 50%;
      animation: sneezeSpray 1s ease-out forwards;
    }

    @keyframes sneezeSpray {
      0% { transform: scale(1) translateX(0); opacity: 1; }
      100% { transform: scale(0) translateX(100px); opacity: 0; }
    }

    /* Add sleeping eyes animation */
    @keyframes sleepyEyes {
      0%, 100% { transform: scaleY(1); }
      50% { transform: scaleY(0.1); }
    }

    .orb-container.sleeping .eye {
      animation: sleepyEyes 3s ease-in-out infinite !important;
    }

    /* Add party eyes animation */
    @keyframes partyEyes {
      0% { background: red; }
      33% { background: green; }
      66% { background: blue; }
      100% { background: red; }
    }

    .orb-container.partying .eye {
      animation: partyEyes 1s linear infinite !important;
    }

    /* Add sneeze eyes animation */
    @keyframes sneezeEyes {
      0% { transform: scaleY(1); }
      50% { transform: scaleY(0.1) rotate(10deg); }
      100% { transform: scaleY(1); }
    }

    .orb-container.sneezing .eye {
      animation: sneezeEyes 0.5s ease-out !important;
    }

    /* Add these styles for search results and music visualization */
    .search-results {
      position: absolute;
      top: -220px;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      width: 300px;
      background: rgba(147, 51, 234, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 10px;
      z-index: 1000;
      opacity: 0;
      transition: all 0.3s ease-out;
      pointer-events: auto;
    }

    .result-item {
      display: flex;
      align-items: center;
      padding: 10px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      animation: slideIn 0.3s ease-out forwards;
      opacity: 0;
      position: relative;
      z-index: 1000;
      pointer-events: auto; /* Ensure clicks are captured */
    }

    .result-item * {
      pointer-events: none; /* Make child elements pass clicks to parent */
    }

    .result-item:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Add animation delay for each result item */
    .result-item:nth-child(1) { animation-delay: 0.1s; }
    .result-item:nth-child(2) { animation-delay: 0.2s; }
    .result-item:nth-child(3) { animation-delay: 0.3s; }
    .result-item:nth-child(4) { animation-delay: 0.4s; }
    .result-item:nth-child(5) { animation-delay: 0.5s; }

    .result-thumb {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      overflow: hidden;
      margin-right: 10px;
    }

    .result-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .result-info {
      flex: 1;
    }

    .result-title {
      color: white;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .result-channel {
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
    }

    .search-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgb(147, 51, 234);
      border-radius: 50%;
      animation: searchFloat 1s ease-out forwards;
    }

    .music-particle {
      position: absolute;
      width: 6px;
      height: 6px;
      background: rgb(147, 51, 234);
      border-radius: 50%;
      animation: musicFloat 1s ease-out forwards;
    }

    @keyframes searchFloat {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-50px) scale(0); opacity: 0; }
    }

    @keyframes musicFloat {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      50% { transform: translateY(-30px) scale(1.5); opacity: 0.5; }
      100% { transform: translateY(-60px) scale(0); opacity: 0; }
    }

    /* Add these styles for music controls and visualization */
    .music-controls {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(147, 51, 234, 0.1);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 20px;
      display: none;
      align-items: center;
      gap: 15px;
      z-index: 1000;
    }

    .music-controls.active {
      display: flex;
    }

    .control-button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }

    .control-button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .control-button svg {
      width: 24px;
      height: 24px;
      fill: white;
    }

    .progress-container {
      flex: 1;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }

    .progress-bar {
      height: 100%;
      background: rgb(147, 51, 234);
      border-radius: 2px;
      width: 0;
      transition: width 0.1s linear;
    }

    .time-display {
      color: white;
      font-size: 12px;
      min-width: 100px;
      text-align: center;
    }

    /* Disco lights */
    .disco-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      display: none;
    }

    .disco-container.active {
      display: block;
    }

    .disco-light {
      position: absolute;
      width: 0;
      height: 0;
      border-radius: 50%;
      opacity: 0;
      animation: discoLight 4s infinite;
    }

    @keyframes discoLight {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(2); opacity: 0.1; }
      100% { transform: scale(0); opacity: 0; }
    }

    /* Music visualization particles */
    .visualizer-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      display: none;
    }

    .visualizer-container.active {
      display: block;
    }

    .visualizer-particle {
      position: absolute;
      width: 4px;
      height: 20px;
      background: rgb(147, 51, 234);
      border-radius: 2px;
      transform-origin: bottom;
      animation: visualizerBounce 0.5s infinite;
    }

    @keyframes visualizerBounce {
      0%, 100% { transform: scaleY(0.2); }
      50% { transform: scaleY(1); }
    }

    /* Add these styles for the settings menu */
    .settings-icon {
      position: fixed;
      top: 20px;
      right: 80px; /* Position after chat history icon */
      width: 40px;
      height: 40px;
      background: rgba(147, 51, 234, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 1000;
    }

    .settings-icon:hover {
      background: rgba(147, 51, 234, 0.2);
      transform: rotate(45deg);
    }

    .settings-icon svg {
      width: 24px;
      height: 24px;
      fill: white;
    }

    .settings-menu {
      position: fixed;
      top: 70px;
      right: 80px;
      background: rgba(147, 51, 234, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      width: 300px;
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: all 0.3s;
      z-index: 999;
    }

    .settings-menu.active {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .settings-section {
      margin-bottom: 15px;
    }

    .settings-title {
      color: white;
      font-size: 18px;
      margin-bottom: 15px;
      font-weight: 500;
    }

    .settings-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .settings-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
    }

    /* Toggle switch styles */
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.2);
      transition: .4s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: rgb(147, 51, 234);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Original orb structure -->
  <div id="orb-container" class="orb-container">
    <div class="magical-orb">
      <div class="thunder-wave"></div>
      <div class="thunder-wave" style="animation-delay: -1.5s"></div>
      <div class="orb-inner"></div>
      <div class="eyes-container">
        <div class="eye eye-left">
          <div class="pupil"></div>
        </div>
        <div class="eye eye-right">
          <div class="pupil"></div>
        </div>
      </div>
      <div class="emotion-particles"></div>
      <div class="lightning-effect"></div>
    </div>
  </div>

  <!-- Add this after the orb structure but before the chat container -->
  <div class="speech-bubble" id="speechBubble"></div>

  <!-- Add this after the orb structure -->
  <div class="idle-message" id="idleMessage">Click me to chat!</div>

  <!-- Add this after the orb container but before the chat container -->
  <div class="keyboard-icon" id="keyboardIcon" title="Toggle keyboard input">
    <svg viewBox="0 0 24 24">
      <path d="M20,5H4C2.9,5,2,5.9,2,7v10c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V7C22,5.9,21.1,5,20,5z M20,17H4V7h16V17z"/>
      <path d="M11,8h2v2h-2V8z"/>
      <path d="M8,8h2v2H8V8z"/>
      <path d="M5,8h2v2H5V8z"/>
      <path d="M14,8h2v2h-2V8z"/>
      <path d="M17,8h2v2h-2V8z"/>
      <path d="M8,11h2v2H8V11z"/>
      <path d="M11,11h2v2h-2V11z"/>
      <path d="M14,11h2v2h-2V11z"/>
      <path d="M17,11h2v2h-2V11z"/>
      <path d="M8,14h8v2H8V14z"/>
    </svg>
  </div>

  <!-- Add this after the keyboard icon but before the chat container -->
  <div class="thunderbolt-icon" id="thunderboltIcon" title="Strike with lightning">
    <svg viewBox="0 0 24 24">
      <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
    </svg>
  </div>

  <!-- Add this before the chat container -->
  <a href="chat-history.html" class="chat-history-icon" title="View Chat History">
    <svg viewBox="0 0 24 24">
      <path d="M20,2H4C2.9,2,2,2.9,2,4v18l4-4h14c1.1,0,2-0.9,2-2V4C22,2.9,21.1,2,20,2z M20,16H6l-2,2V4h16V16z"/>
    </svg>
  </a>

  <!-- Update the chat container to remove chat history -->
  <div class="chat-container" id="chatContainer">
    <div class="input-group">
      <input type="text" class="chat-input" id="userInput" placeholder="Ask Stormy anything...">
      <button class="send-button" id="sendButton">Send</button>
    </div>
  </div>

  <div id="captionContainer" class="caption-container">
    <div class="caption-text"></div>
  </div>

  <!-- Add these new icons after the thunderbolt icon -->
  <div class="tickle-icon" id="tickleIcon" title="Tickle the orb">
    <svg viewBox="0 0 24 24">
      <path d="M19.59 7L12 14.59 6.41 9H10V7H3v7h2V9.41L12 16.41 19.59 9H16V7h7v7h-2V9.41L14.41 16 21 22.59 19.59 21 13 14.41 6.41 21 5 22.59 6.41 16 13z"/>
    </svg>
  </div>

  <div class="love-icon" id="loveIcon" title="Show some love">
    <svg viewBox="0 0 24 24">
      <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
    </svg>
  </div>

  <div class="dizzy-icon" id="dizzyIcon" title="Make the orb dizzy">
    <svg viewBox="0 0 24 24">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>
      <path d="M15 16H9v-2h6v2zm0-4H9v-2h6v2zm0-4H9V6h6v2z"/>
    </svg>
  </div>

  <!-- Add these new interaction icons -->
  <div class="sleep-icon" id="sleepIcon" title="Make the orb sleepy">
    <svg viewBox="0 0 24 24">
      <path d="M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36c-0.98,1.37-2.58,2.26-4.4,2.26 c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/>
    </svg>
  </div>

  <div class="party-icon" id="partyIcon" title="Start a party!">
    <svg viewBox="0 0 24 24">
      <path d="M2,22l14-14L14,6l-2,2l-2-2L8,8l-2-2L4,8L2,22z M14,6l8-4l-4,8L14,6z"/>
    </svg>
  </div>

  <div class="sneeze-icon" id="sneezeIcon" title="Make the orb sneeze">
    <svg viewBox="0 0 24 24">
      <path d="M12,2C6.47,2,2,6.47,2,12s4.47,10,10,10s10-4.47,10-10S17.53,2,12,2z M12,20c-4.41,0-8-3.59-8-8s3.59-8,8-8s8,3.59,8,8 S16.41,20,12,20z"/>
      <path d="M9.59,8.59L12,11l2.41-2.41L16,10l-4,4l-4-4L9.59,8.59z"/>
    </svg>
  </div>

  <!-- Add these elements after the chat container -->
  <div class="music-controls" id="musicControls">
    <button class="control-button" id="prevButton">
      <svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
    </button>
    <button class="control-button" id="playPauseButton">
      <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <button class="control-button" id="nextButton">
      <svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
    </button>
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="time-display">
      <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
    </div>
  </div>

  <div class="disco-container" id="discoContainer"></div>
  <div class="visualizer-container" id="visualizerContainer"></div>

  <!-- Add this after the chat-history-icon -->
  <div class="settings-icon" id="settingsIcon" title="Settings">
    <svg viewBox="0 0 24 24">
      <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
    </svg>
  </div>

  <div class="settings-menu" id="settingsMenu">
    <div class="settings-section">
      <div class="settings-title">Music Settings</div>
      <div class="settings-option">
        <span class="settings-label">Auto-play songs</span>
        <label class="toggle-switch">
          <input type="checkbox" id="autoPlayToggle">
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
  </div>

  <script>
    // Add these constants at the beginning of your script section
    const YT_SEARCH_API = 'https://api.paxsenix.us.kg/yt/search';
    const YT_DOWNLOAD_API = 'https://api.paxsenix.us.kg/yt/yttomp4';

    // Original orb interaction code
    const orbContainer = document.getElementById('orb-container');
    const pupils = document.querySelectorAll('.pupil');
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    let lastMovementTime = 0;
    const idleThreshold = 500;

    // Chat functionality
    const chatContainer = document.getElementById('chatContainer');
    const userInput = document.getElementById('userInput');
    const sendButton = document.getElementById('sendButton');
    const magicalOrb = document.querySelector('.magical-orb');

    // Toggle chat on orb click
    orbContainer.addEventListener('click', (e) => {
      // Check if click is on a result item
      const resultItem = e.target.closest('.result-item');
      if (resultItem) {
        // Prevent starting voice recognition
        e.stopPropagation();
        return;
      }

      if (!isDragging) {
        if (!isListening && recognition) {
          isListening = true;
          recognition.start();
          orbContainer.classList.add('listening');
          speechBubble.classList.add('listening');
          speechBubble.textContent = "I'm listening...";
          chatContainer.classList.remove('visible');
          keyboardIcon.classList.remove('active');
        } else if (isListening) {
          isListening = false;
          recognition.stop();
          orbContainer.classList.remove('listening');
          speechBubble.classList.remove('listening');
        }
        idleMessage.classList.remove('visible');
      }
    });

    // API configuration
    const API_KEY = 'AIzaSyBlvhpuRx-ispBO9mCxnMNu78FQ4rLnmrI'; // Replace with your actual API key
    const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

    // Add these functions to the script section
    function showCaption(text) {
      const captionContainer = document.getElementById('captionContainer');
      const captionText = captionContainer.querySelector('.caption-text');
      captionText.textContent = text;
      captionContainer.style.opacity = '1';
    }

    function hideCaption() {
      const captionContainer = document.getElementById('captionContainer');
      captionContainer.style.opacity = '0';
    }

    // Add click animation
    orbContainer.addEventListener('mousedown', () => {
      magicalOrb.classList.add('orb-click');
    });

    orbContainer.addEventListener('mouseup', () => {
      magicalOrb.classList.remove('orb-click');
    });

    // Add this function to store messages
    function saveMessage(text, type) {
      const history = JSON.parse(localStorage.getItem('stormyChatHistory') || '[]');
      history.push({
        text,
        type,
        timestamp: new Date().toISOString()
      });
      localStorage.setItem('stormyChatHistory', JSON.stringify(history));
    }

    // Initialize speech synthesis and get voices
    let speechSynthesis = window.speechSynthesis;
    let voices = [];

    function loadVoices() {
      voices = speechSynthesis.getVoices();
    }

    // Load voices when they're available
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = loadVoices;
    }

    // Add these functions to handle speech recognition
    let recognition;
    let isListening = false;

    function initSpeechRecognition() {
      if ('webkitSpeechRecognition' in window) {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
          orbContainer.classList.add('listening');
          speechBubble.textContent = "I'm listening...";
          speechBubble.classList.add('active', 'listening');
          isListening = true;
        };

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript.toLowerCase();
          console.log('Voice command:', transcript);
          
          if (transcript.includes('play')) {
            const query = transcript.replace('play', '').trim();
            console.log('Play query:', query);
            handlePlayCommand(query);
          } else {
            handleUserInput(transcript);
          }
          
          // Stop listening after processing the command
          recognition.stop();
          orbContainer.classList.remove('listening');
          speechBubble.classList.remove('listening');
        };

        recognition.onend = () => {
          orbContainer.classList.remove('listening');
          speechBubble.classList.remove('active', 'listening');
          isListening = false;
        };

        recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          orbContainer.classList.remove('listening');
          speechBubble.textContent = "Sorry, I couldn't hear that.";
          speechBubble.classList.remove('listening');
          setTimeout(() => speechBubble.classList.remove('active'), 2000);
          isListening = false;
        };
      }
    }

    // Initialize speech recognition
    initSpeechRecognition();

    // Update the handleUserInput function to better handle text processing
    function cleanTextForSpeech(text) {
      // Remove emojis
      text = text.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, '');
      
      // Remove markdown and code blocks
      text = text.replace(/```[\s\S]*?```/g, '')
                .replace(/`.*?`/g, '')
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/\*(.*?)\*/g, '$1')
                .replace(/#+ /g, '')
                .trim();
      
      // Add proper punctuation for better speech
      text = text.replace(/([.!?])(\w)/g, '$1 $2');
      
      return text;
    }

    // Update the speech synthesis part in handleUserInput
    async function handleUserInput(directInput) {
      const input = directInput || userInput.value.trim();
      if (!input) return;

      // Check for play command in text input
      if (input.toLowerCase().startsWith('play ')) {
        const query = input.slice(5).trim();
        console.log('Play command from text:', query);
        handlePlayCommand(query);
        if (!directInput) userInput.value = '';
        return;
      }

      saveMessage(input, 'user');
      if (!directInput) userInput.value = '';

      const speechBubble = document.getElementById('speechBubble');
      speechBubble.textContent = "Thinking...";
      speechBubble.classList.add('active');
      
      orbContainer.setAttribute('data-emotion', 'neutral');
      magicalOrb.parentElement.classList.add('thinking');
      userInput.disabled = true;
      sendButton.disabled = true;

      try {
        const response = await fetch(`${API_URL}?key=${API_KEY}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: `You are Stormy, an emotional AI companion. Respond with raw JSON only, no markdown, no code blocks:
                {"emotion": "emotion_type", "response": "your_response"}

                IMPORTANT: Return ONLY the JSON object, nothing else.
                
                Emotions available: happy, sad, angry, confused, neutral
                
                Examples of valid responses:
                {"emotion": "happy", "response": "That's wonderful! I'm so glad to hear that!"}
                {"emotion": "angry", "response": "I don't appreciate that tone."}
                {"emotion": "confused", "response": "Hmm, that's quite complex."}
                
                Rules for emotions:
                - happy: for compliments, positive interactions
                - sad: for negative news, empathy
                - angry: for rude behavior
                - confused: for complex topics
                - neutral: for normal questions

                User says: ${input}`
              }]
            }]
          })
        });

        const data = await response.json();
        
        if (data.candidates && data.candidates[0]) {
          try {
            // Clean and parse JSON response
            let responseText = data.candidates[0].content.parts[0].text;
            // Remove markdown code blocks and clean the text
            responseText = responseText.replace(/```json\n?|\n?```/g, '').trim();
            console.log('Cleaned response:', responseText);
            
            const jsonResponse = JSON.parse(responseText);
            console.log('Parsed JSON:', jsonResponse);

            // Set emotion and update orb
            const validEmotions = ['happy', 'sad', 'angry', 'confused', 'neutral'];
            const emotion = validEmotions.includes(jsonResponse.emotion) ? jsonResponse.emotion : 'neutral';
            
            console.log('Setting emotion to:', emotion);
            orbContainer.setAttribute('data-emotion', emotion);
            magicalOrb.parentElement.classList.remove('thinking');
            
            // Show response
            const formattedAnswer = jsonResponse.response;
            speechBubble.textContent = formattedAnswer;
            
            // Configure and play speech
            const speech = new SpeechSynthesisUtterance(formattedAnswer);
            
            // Select a female voice
            const femaleVoice = voices.find(voice => 
              voice.name.includes('Female') || 
              voice.name.includes('Samantha') || 
              voice.name.includes('Google UK English Female')
            );
            
            if (femaleVoice) {
              speech.voice = femaleVoice;
            }
            
            // Improve voice quality
            speech.pitch = 1.1;
            speech.volume = 0.9;
            
            // Adjust voice based on emotion
            switch(emotion) {
              case 'happy':
                speech.pitch = 1.3;
                speech.rate = 1.1;
                break;
              case 'sad':
                speech.pitch = 0.9;
                speech.rate = 0.9;
                break;
              case 'angry':
                speech.pitch = 1.4;
                speech.rate = 1.2;
                break;
              case 'confused':
                speech.pitch = 1.1;
                speech.rate = 0.95;
                break;
              default:
                speech.pitch = 1.2;
                speech.rate = 1.0;
            }

            speechSynthesis.cancel();
            speechSynthesis.speak(speech);

            // Keep speech bubble visible while speaking
            speech.onstart = () => {
              speechBubble.classList.add('active');
            };

            // Only hide speech bubble after a delay when speech ends
            speech.onend = () => {
              setTimeout(() => {
                orbContainer.setAttribute('data-emotion', 'neutral');
                speechBubble.classList.remove('active');
              }, 2000);
            };

          } catch (parseError) {
            console.error('Parse error:', parseError);
            orbContainer.setAttribute('data-emotion', 'confused');
            speechBubble.textContent = "Sorry, I'm having trouble understanding that.";
          }
        }
      } catch (error) {
        console.error('Network error:', error);
        orbContainer.setAttribute('data-emotion', 'sad');
        speechBubble.textContent = "Sorry, I'm having trouble connecting right now.";
      } finally {
        userInput.disabled = false;
        sendButton.disabled = false;
      }
    }

    sendButton.addEventListener('click', () => {
      const userInput = document.getElementById('userInput');
      const speechBubble = document.getElementById('speechBubble');
      const prompt = userInput.value.trim();
      if (prompt) {
        handleUserInput(prompt);
      }
    });

    // Add idle message handler
    let idleMessageTimeout;

    function showIdleMessage() {
      const idleMessage = document.getElementById('idleMessage');
      const chatContainer = document.getElementById('chatContainer');
      
      if (!chatContainer.classList.contains('visible')) {
        idleMessage.classList.add('visible');
        setTimeout(() => {
          idleMessage.classList.remove('visible');
        }, 3000);
      }
    }

    // Show idle message periodically
    setInterval(showIdleMessage, 10000);

    // Show idle message after page load
    setTimeout(showIdleMessage, 2000);

    // Hide idle message when moving mouse over orb
    orbContainer.addEventListener('mouseenter', () => {
      const idleMessage = document.getElementById('idleMessage');
      idleMessage.classList.add('visible');
    });

    orbContainer.addEventListener('mouseleave', () => {
      const idleMessage = document.getElementById('idleMessage');
      idleMessage.classList.remove('visible');
    });

    // Add this to make sure speech bubble is properly positioned relative to the orb
    window.addEventListener('load', () => {
      const speechBubble = document.getElementById('speechBubble');
      const orbContainer = document.getElementById('orb-container');
      orbContainer.appendChild(speechBubble);
    });

    // Add this to your script section
    const keyboardIcon = document.getElementById('keyboardIcon');

    keyboardIcon.addEventListener('click', () => {
      if (isListening) {
        // Stop listening if active
        recognition.stop();
      }
      chatContainer.classList.toggle('visible');
      keyboardIcon.classList.toggle('active');
      
      if (chatContainer.classList.contains('visible')) {
        userInput.focus();
      }
    });

    // Add this function to create particle effects
    function createParticles(emotion) {
      const particlesContainer = document.querySelector('.emotion-particles');
      particlesContainer.innerHTML = '';
      
      const colors = {
        happy: ['#FFD700', '#FFA500', '#FF8C00'],
        sad: ['#4169E1', '#1E90FF', '#87CEEB'],
        angry: ['#FF4500', '#FF6347', '#FF7F50'],
        confused: ['#BA55D3', '#9370DB', '#8A2BE2'],
        neutral: ['#9333EA', '#7B1FA2', '#6A1B9A']
      };

      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.backgroundColor = colors[emotion][Math.floor(Math.random() * 3)];
        particle.style.animationDelay = `${Math.random() * 2}s`;
        particlesContainer.appendChild(particle);
      }
    }

    // Initialize thunderbolt functionality
    const thunderboltIcon = document.getElementById('thunderboltIcon');
    const lightningEffect = document.querySelector('.lightning-effect');

    thunderboltIcon.addEventListener('click', () => {
      // Set emotion to hurt
      orbContainer.setAttribute('data-emotion', 'angry');
      createParticles('angry');

      // Activate lightning effect
      lightningEffect.classList.add('active');
      
      // Add hurt state to orb
      orbContainer.classList.add('hurt');
      
      // Show hurt reaction
      const speechBubble = document.getElementById('speechBubble');
      speechBubble.textContent = "Ouch! That hurt!";
      speechBubble.classList.add('active');
      
      // Play hurt sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);

      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.1);
      
      // Remove effects after animation
      setTimeout(() => {
        lightningEffect.classList.remove('active');
        orbContainer.classList.remove('hurt');
        speechBubble.classList.remove('active');
        // Reset emotion after hurt animation
        orbContainer.setAttribute('data-emotion', 'neutral');
        createParticles('neutral');
      }, 1000);
      
      // Prevent multiple clicks during animation
      thunderboltIcon.style.pointerEvents = 'none';
      setTimeout(() => {
        thunderboltIcon.style.pointerEvents = 'auto';
      }, 1000);
      
      // Play thunder sound
      playThunderboltSound();
    });

    // Add random eye movement during hurt state
    function randomEyeMovement() {
      if (orbContainer.classList.contains('hurt')) {
        const pupils = document.querySelectorAll('.pupil');
        pupils.forEach(pupil => {
          const x = (Math.random() - 0.5) * 100;
          const y = (Math.random() - 0.5) * 100;
          pupil.style.transform = `translate(${x}%, ${y}%)`;
        });
      }
    }

    // Start random eye movement during hurt state
    setInterval(randomEyeMovement, 100);

    // Add these new interaction handlers to your script section
    const tickleIcon = document.getElementById('tickleIcon');
    const loveIcon = document.getElementById('loveIcon');
    const dizzyIcon = document.getElementById('dizzyIcon');

    // Tickle interaction
    tickleIcon.addEventListener('click', () => {
      orbContainer.classList.add('tickled');
      magicalOrb.style.animation = 'tickle 0.5s ease-in-out';
      
      // Show reaction
      speechBubble.textContent = "Hehe, that tickles!";
      speechBubble.classList.add('active');
      
      // Create tickle particles
      for (let i = 0; i < 8; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.backgroundColor = `hsl(${Math.random() * 60 + 300}, 70%, 70%)`;
        document.querySelector('.emotion-particles').appendChild(particle);
      }
      
      // Reset after animation
      setTimeout(() => {
        orbContainer.classList.remove('tickled');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
      }, 2000);
      
      // Play tickle sound
      playTickleSound();
    });

    // Love interaction
    loveIcon.addEventListener('click', () => {
      orbContainer.classList.add('loved');
      orbContainer.setAttribute('data-emotion', 'happy');
      magicalOrb.style.animation = 'love 1s ease-in-out';
      
      // Show reaction
      speechBubble.textContent = "Aww, I love you too! ";
      speechBubble.classList.add('active');
      
      // Create heart particles
      for (let i = 0; i < 10; i++) {
        const heart = document.createElement('div');
        heart.className = 'heart-particle';
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.top = `${Math.random() * 100}%`;
        document.querySelector('.emotion-particles').appendChild(heart);
      }
      
      // Reset after animation
      setTimeout(() => {
        orbContainer.classList.remove('loved');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
        orbContainer.setAttribute('data-emotion', 'neutral');
      }, 3000);
      
      // Play giggle sound
      playGiggleSound();
    });

    // Dizzy interaction
    dizzyIcon.addEventListener('click', () => {
      orbContainer.classList.add('dizzy');
      magicalOrb.style.animation = 'dizzy 1s linear infinite';
      
      // Show reaction
      speechBubble.textContent = "Whoooa... everything's spinning! @_@";
      speechBubble.classList.add('active');
      
      // Create star particles
      for (let i = 0; i < 6; i++) {
        const star = document.createElement('div');
        star.className = 'star-particle';
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        document.querySelector('.emotion-particles').appendChild(star);
      }
      
      // Reset after animation
      setTimeout(() => {
        orbContainer.classList.remove('dizzy');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
      }, 3000);
    });

    // Add hover effects for icons
    [tickleIcon, loveIcon, dizzyIcon].forEach(icon => {
      icon.addEventListener('mouseover', () => {
        const caption = icon.getAttribute('title');
        showCaption(caption);
      });
      
      icon.addEventListener('mouseout', () => {
        hideCaption();
      });
    });

    // Add these new interaction handlers
    const sleepIcon = document.getElementById('sleepIcon');
    const partyIcon = document.getElementById('partyIcon');
    const sneezeIcon = document.getElementById('sneezeIcon');

    // Sleep interaction
    sleepIcon.addEventListener('click', () => {
      clearParticles(); // Clear existing particles
      orbContainer.classList.add('sleeping');
      magicalOrb.style.animation = 'sleep 3s ease-in-out infinite';
      
      // Show reaction
      speechBubble.textContent = "Zzzz... *snore*";
      speechBubble.classList.add('active');
      
      // Create floating Z's with unique class
      const createZ = () => {
        const z = document.createElement('div');
        z.className = 'sleep-particle z-particle';
        z.textContent = 'Z';
        z.style.left = '60%';
        z.style.top = '30%';
        document.querySelector('.emotion-particles').appendChild(z);
        
        setTimeout(() => z.remove(), 2000);
      };
      
      const zInterval = setInterval(createZ, 500);
      
      setTimeout(() => {
        orbContainer.classList.remove('sleeping');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
        clearInterval(zInterval);
        clearParticles();
      }, 5000);
    });

    // Party interaction
    partyIcon.addEventListener('click', () => {
      orbContainer.classList.add('partying');
      magicalOrb.style.animation = 'party 1s linear infinite';
      
      // Show reaction
      speechBubble.textContent = "Let's party! ";
      speechBubble.classList.add('active');
      
      // Create confetti
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
      
      const createConfetti = () => {
        for (let i = 0; i < 10; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = `${Math.random() * 100}%`;
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          document.querySelector('.emotion-particles').appendChild(confetti);
          
          // Remove confetti after animation
          setTimeout(() => confetti.remove(), 3000);
        }
      };
      
      // Create confetti periodically
      const confettiInterval = setInterval(createConfetti, 200);
      
      // Reset after animation
      setTimeout(() => {
        orbContainer.classList.remove('partying');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
        clearInterval(confettiInterval);
      }, 5000);
    });

    // Sneeze interaction
    sneezeIcon.addEventListener('click', () => {
      orbContainer.classList.add('sneezing');
      
      // Build up to sneeze
      speechBubble.textContent = "Ah... ah... ";
      speechBubble.classList.add('active');
      
      setTimeout(() => {
        // Sneeze!
        magicalOrb.style.animation = 'sneeze 0.5s ease-out';
        speechBubble.textContent = "ACHOO! ";
        
        // Create sneeze particles
        for (let i = 0; i < 20; i++) {
          const droplet = document.createElement('div');
          droplet.className = 'sneeze-droplet';
          droplet.style.left = '50%';
          droplet.style.top = '50%';
          droplet.style.transform = `rotate(${Math.random() * 360}deg)`;
          document.querySelector('.emotion-particles').appendChild(droplet);
        }
        
        // Play sneeze sound
        const sneezeSound = new Audio('data:audio/wav;base64,...'); // Add appropriate sound data
        sneezeSound.play();
      }, 1000);
      
      // Reset after animation
      setTimeout(() => {
        orbContainer.classList.remove('sneezing');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
      }, 2000);
    });

    // Add hover effects for new icons
    [sleepIcon, partyIcon, sneezeIcon].forEach(icon => {
      icon.addEventListener('mouseover', () => {
        const caption = icon.getAttribute('title');
        showCaption(caption);
      });
      
      icon.addEventListener('mouseout', () => {
        hideCaption();
      });
    });

    // Add sound effects functions
    function playThunderboltSound() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create oscillator for thunder crack
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      
      // Create thunder rumble
      const rumble = audioContext.createOscillator();
      const rumbleGain = audioContext.createGain();
      
      rumble.connect(rumbleGain);
      rumbleGain.connect(audioContext.destination);
      
      rumble.type = 'sine';
      rumble.frequency.setValueAtTime(50, audioContext.currentTime);
      rumbleGain.gain.setValueAtTime(0.05, audioContext.currentTime);
      
      // Play the sounds
      oscillator.start();
      rumble.start();
      
      oscillator.stop(audioContext.currentTime + 0.1);
      rumble.stop(audioContext.currentTime + 0.5);
    }

    function playTickleSound() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create multiple high-pitched beeps
      for (let i = 0; i < 5; i++) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(1000 + (i * 200), audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime + (i * 0.1));
        oscillator.stop(audioContext.currentTime + (i * 0.1) + 0.1);
      }
    }

    // Add giggle sound to love interaction
    function playGiggleSound() {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      for (let i = 0; i < 3; i++) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800 - (i * 100), audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime + (i * 0.2));
        oscillator.stop(audioContext.currentTime + (i * 0.2) + 0.2);
      }
    }

    // Add this function to properly clean up particles
    function clearParticles() {
      const particlesContainer = document.querySelector('.emotion-particles');
      particlesContainer.innerHTML = '';
    }

    // Update each interaction to use its own particle class and cleanup

    // Sleep interaction
    sleepIcon.addEventListener('click', () => {
      clearParticles(); // Clear existing particles
      orbContainer.classList.add('sleeping');
      magicalOrb.style.animation = 'sleep 3s ease-in-out infinite';
      
      // Show reaction
      speechBubble.textContent = "Zzzz... *snore*";
      speechBubble.classList.add('active');
      
      // Create floating Z's with unique class
      const createZ = () => {
        const z = document.createElement('div');
        z.className = 'sleep-particle z-particle';
        z.textContent = 'Z';
        z.style.left = '60%';
        z.style.top = '30%';
        document.querySelector('.emotion-particles').appendChild(z);
        
        setTimeout(() => z.remove(), 2000);
      };
      
      const zInterval = setInterval(createZ, 500);
      
      setTimeout(() => {
        orbContainer.classList.remove('sleeping');
        magicalOrb.style.animation = '';
        speechBubble.classList.remove('active');
        clearInterval(zInterval);
        clearParticles();
      }, 5000);
    });

    // Add voice command play functionality
    async function handlePlayCommand(query) {
      console.log('Handling play command for:', query);
      
      // Show searching animation
      orbContainer.setAttribute('data-emotion', 'thinking');
      speechBubble.textContent = `Searching for "${query}"...`;
      speechBubble.classList.add('active');
      
      // Clear any existing results
      const oldResults = document.querySelector('.search-results');
      if (oldResults) {
        oldResults.remove();
      }
      
      // Create searching particles
      clearParticles();
      const createSearchParticle = () => {
        const particle = document.createElement('div');
        particle.className = 'search-particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        document.querySelector('.emotion-particles').appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      };
      
      const searchInterval = setInterval(createSearchParticle, 100);

      try {
        console.log('Fetching results from:', `${YT_SEARCH_API}?q=${encodeURIComponent(query)}&type=video`);
        const response = await fetch(`${YT_SEARCH_API}?q=${encodeURIComponent(query)}&type=video`);
        const data = await response.json();
        console.log('Search results:', data);

        clearInterval(searchInterval);
        clearParticles();
        
        if (!data.ok || !data.results || data.results.length === 0) {
          throw new Error('No results found');
        }

        // Store search results for auto-play
        currentSearchResults = data.results.slice(0, 5);
        currentPlayingIndex = 0;

        // Create results container
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'search-results';
        
        // Add results
        resultsContainer.innerHTML = currentSearchResults.map((video, index) => `
          <div class="result-item" data-video-id="${video.videoId}" data-title="${video.title.replace(/"/g, '&quot;')}">
            <div class="result-thumb">
              <img src="${video.thumbnails[0].url}" alt="${video.title}">
            </div>
            <div class="result-info">
              <div class="result-title">${video.title}</div>
              <div class="result-channel">${video.channelName}</div>
            </div>
          </div>
        `).join('');

        // Add click handlers
        const resultItems = resultsContainer.querySelectorAll('.result-item');
        resultItems.forEach(item => {
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            const videoId = item.dataset.videoId;
            const title = item.dataset.title;
            playSelectedTrack(videoId, title);
          });
        });

        orbContainer.appendChild(resultsContainer);
        orbContainer.setAttribute('data-emotion', 'happy');
        speechBubble.textContent = "Here's what I found!";
        
        // Add fade-in animation
        setTimeout(() => {
          resultsContainer.style.opacity = '1';
          resultsContainer.style.transform = 'translateX(-50%) translateY(0)';
        }, 100);

        // Auto-play if enabled
        if (autoPlayEnabled) {
          // Wait a moment to show results before auto-playing
          setTimeout(() => {
            const firstVideo = currentSearchResults[0];
            speechBubble.textContent = `Auto-playing: ${firstVideo.title}`;
            playSelectedTrack(firstVideo.videoId, firstVideo.title);
          }, 1500);
        }

      } catch (error) {
        console.error('Error in handlePlayCommand:', error);
        clearInterval(searchInterval);
        clearParticles();
        orbContainer.setAttribute('data-emotion', 'sad');
        speechBubble.textContent = `Sorry, ${error.message}`;
      }
    }

    // Function to try playing next available song
    async function tryPlayNext() {
      if (currentPlayingIndex >= currentSearchResults.length) {
        orbContainer.setAttribute('data-emotion', 'sad');
        speechBubble.textContent = "Sorry, couldn't play any of the results";
        return;
      }

      const video = currentSearchResults[currentPlayingIndex];
      try {
        await playSelectedTrack(video.videoId, video.title);
      } catch (error) {
        console.error('Error playing track:', error);
        currentPlayingIndex++;
        if (autoPlayEnabled) {
          tryPlayNext();
        }
      }
    }

    // Update playSelectedTrack to handle errors for auto-play
    async function playSelectedTrack(videoId, title) {
      // Remove search results
      const resultsContainer = document.querySelector('.search-results');
      if (resultsContainer) {
        resultsContainer.style.opacity = '0';
        resultsContainer.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => resultsContainer.remove(), 300);
      }

      orbContainer.setAttribute('data-emotion', 'thinking');
      speechBubble.textContent = `Loading "${title}"...`;
      
      try {
        const response = await fetch(`${YT_DOWNLOAD_API}?url=https://www.youtube.com/watch?v=${videoId}`);
        const data = await response.json();

        if (!data.ok || !data.audio) {
          throw new Error('Failed to load audio');
        }

        // Find 128kbps audio stream
        const audioStream = data.audio.find(stream => stream.name.includes('128Kbps')) || data.audio[0];
        
        if (!audioStream) {
          throw new Error('No suitable audio stream found');
        }

        // Stop any currently playing audio
        if (window.currentAudio) {
          window.currentAudio.pause();
          document.getElementById('musicControls').classList.remove('active');
          document.getElementById('discoContainer').classList.remove('active');
          document.getElementById('visualizerContainer').classList.remove('active');
        }

        // Create audio player
        const audio = new Audio(audioStream.url);
        window.currentAudio = audio;
        
        // Add music controls
        updateMusicControls(audio, title);
        
        // Add disco lights
        createDiscoLights();
        
        // Add music visualization
        createMusicVisualization(audio);
        
        // Show playing animation
        orbContainer.setAttribute('data-emotion', 'happy');
        speechBubble.textContent = `Playing "${title}" `;
        
        // Add music visualization particles
        clearParticles();
        const visualizer = setInterval(() => {
          const particle = document.createElement('div');
          particle.className = 'music-particle';
          particle.style.left = `${Math.random() * 100}%`;
          document.querySelector('.emotion-particles').appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }, 200);

        await audio.play();
        
        // Handle errors during playback
        audio.onerror = () => {
          if (autoPlayEnabled) {
            currentPlayingIndex++;
            tryPlayNext();
          }
        };
        
        // Handle end of playback
        audio.onended = () => {
          clearInterval(visualizer);
          clearParticles();
          document.getElementById('musicControls').classList.remove('active');
          document.getElementById('discoContainer').classList.remove('active');
          document.getElementById('visualizerContainer').classList.remove('active');
          orbContainer.setAttribute('data-emotion', 'neutral');
          speechBubble.textContent = "Hope you enjoyed that!";
          setTimeout(() => speechBubble.classList.remove('active'), 2000);
          
          // Auto-play next song if enabled
          if (autoPlayEnabled) {
            currentPlayingIndex++;
            tryPlayNext();
          }
        };

      } catch (error) {
        clearParticles();
        orbContainer.setAttribute('data-emotion', 'sad');
        speechBubble.textContent = `Sorry, ${error.message}`;
        throw error; // Propagate error for tryPlayNext
      }
    }

    // Function to play selected track
    async function playSelectedTrack(videoId, title) {
      // Remove search results
      const resultsContainer = document.querySelector('.search-results');
      if (resultsContainer) {
        resultsContainer.style.opacity = '0';
        resultsContainer.style.transform = 'translateX(-50%) translateY(-20px)';
        setTimeout(() => resultsContainer.remove(), 300);
      }

      orbContainer.setAttribute('data-emotion', 'thinking');
      speechBubble.textContent = `Loading "${title}"...`;
      
      try {
        const response = await fetch(`${YT_DOWNLOAD_API}?url=https://www.youtube.com/watch?v=${videoId}`);
        const data = await response.json();

        if (!data.ok || !data.audio) {
          throw new Error('Failed to load audio');
        }

        // Find 128kbps audio stream
        const audioStream = data.audio.find(stream => stream.name.includes('128Kbps')) || data.audio[0];
        
        if (!audioStream) {
          throw new Error('No suitable audio stream found');
        }

        // Stop any currently playing audio
        if (window.currentAudio) {
          window.currentAudio.pause();
        }

        // Create audio player
        const audio = new Audio(audioStream.url);
        window.currentAudio = audio;
        
        // Show playing animation
        orbContainer.setAttribute('data-emotion', 'happy');
        speechBubble.textContent = `Playing "${title}" `;
        
        // Add music visualization particles
        clearParticles();
        const visualizer = setInterval(() => {
          const particle = document.createElement('div');
          particle.className = 'music-particle';
          particle.style.left = `${Math.random() * 100}%`;
          document.querySelector('.emotion-particles').appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }, 200);

        await audio.play();
        
        audio.onended = () => {
          clearInterval(visualizer);
          clearParticles();
          orbContainer.setAttribute('data-emotion', 'neutral');
          speechBubble.textContent = "Hope you enjoyed that!";
          setTimeout(() => speechBubble.classList.remove('active'), 2000);
        };

      } catch (error) {
        clearParticles();
        orbContainer.setAttribute('data-emotion', 'sad');
        speechBubble.textContent = `Sorry, ${error.message}`;
      }
    }

    // Add voice command recognition
    function initVoiceCommands() {
      if (!recognition) return;

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript.toLowerCase();
        console.log('Voice command received:', transcript);
        
        orbContainer.classList.remove('listening');
        speechBubble.classList.remove('listening');
        
        if (transcript.includes('play')) {
          const query = transcript.replace('play', '').trim();
          console.log('Play command detected, query:', query);
          handlePlayCommand(query);
        } else {
          handleUserInput(transcript);
        }
      };

      recognition.onend = () => {
        orbContainer.classList.remove('listening');
        speechBubble.classList.remove('listening');
        isListening = false;
      };

      recognition.onerror = (event) => {
        console.error('Voice recognition error:', event.error);
        orbContainer.classList.remove('listening');
        speechBubble.classList.remove('listening');
        isListening = false;
        speechBubble.textContent = "Sorry, I couldn't hear that.";
      };
    }

    // Add this to initialize voice commands
    document.addEventListener('DOMContentLoaded', () => {
      initVoiceCommands();
      // Rest of your DOMContentLoaded handlers...
    });

    // Add these functions to handle music playback and visualization
    function updateMusicControls(audio, title) {
      const controls = document.getElementById('musicControls');
      const playPauseButton = document.getElementById('playPauseButton');
      const progressBar = document.getElementById('progressBar');
      const currentTimeSpan = document.getElementById('currentTime');
      const durationSpan = document.getElementById('duration');
      
      controls.classList.add('active');
      
      // Update play/pause button
      function updatePlayPauseButton() {
        playPauseButton.innerHTML = audio.paused ? 
          '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>' :
          '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
      }
      
      // Update progress and time
      audio.addEventListener('timeupdate', () => {
        const progress = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${progress}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
      });
      
      audio.addEventListener('loadedmetadata', () => {
        durationSpan.textContent = formatTime(audio.duration);
      });
      
      // Handle progress bar clicks
      const progressContainer = document.getElementById('progressContainer');
      progressContainer.addEventListener('click', (e) => {
        const rect = progressContainer.getBoundingClientRect();
        const pos = (e.clientX - rect.left) / rect.width;
        audio.currentTime = pos * audio.duration;
      });
      
      // Play/Pause button click
      playPauseButton.onclick = () => {
        if (audio.paused) audio.play();
        else audio.pause();
        updatePlayPauseButton();
      };
      
      updatePlayPauseButton();
    }

    // Add disco lights
    function createDiscoLights() {
      const container = document.getElementById('discoContainer');
      container.classList.add('active');
      
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
      
      for (let i = 0; i < 5; i++) {
        const light = document.createElement('div');
        light.className = 'disco-light';
        light.style.left = `${Math.random() * 100}%`;
        light.style.top = `${Math.random() * 100}%`;
        light.style.background = colors[i];
        light.style.animationDelay = `${i * 0.8}s`;
        container.appendChild(light);
      }
    }

    // Add music visualization
    function createMusicVisualization(audio) {
      const container = document.getElementById('visualizerContainer');
      container.classList.add('active');
      
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaElementSource(audio);
      
      source.connect(analyser);
      analyser.connect(audioContext.destination);
      
      analyser.fftSize = 256;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      // Create visualizer bars
      for (let i = 0; i < bufferLength; i++) {
        const particle = document.createElement('div');
        particle.className = 'visualizer-particle';
        particle.style.left = `${(i / bufferLength) * 100}%`;
        container.appendChild(particle);
      }
      
      function animate() {
        analyser.getByteFrequencyData(dataArray);
        
        const particles = container.getElementsByClassName('visualizer-particle');
        for (let i = 0; i < particles.length; i++) {
          const height = (dataArray[i] / 255) * 100;
          particles[i].style.height = `${height}px`;
          particles[i].style.opacity = height / 100;
        }
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }

    // Add these variables at the start of your script section
    let autoPlayEnabled = false;
    let currentPlayingIndex = 0;
    let currentSearchResults = [];

    // Add settings menu functionality
    const settingsIcon = document.getElementById('settingsIcon');
    const settingsMenu = document.getElementById('settingsMenu');
    const autoPlayToggle = document.getElementById('autoPlayToggle');

    settingsIcon.addEventListener('click', () => {
      settingsMenu.classList.toggle('active');
    });

    // Close settings menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!settingsMenu.contains(e.target) && !settingsIcon.contains(e.target)) {
        settingsMenu.classList.remove('active');
      }
    });

    // Handle auto-play toggle
    autoPlayToggle.addEventListener('change', () => {
      autoPlayEnabled = autoPlayToggle.checked;
      localStorage.setItem('autoPlayEnabled', autoPlayEnabled);
    });

    // Load saved settings
    document.addEventListener('DOMContentLoaded', () => {
      autoPlayEnabled = localStorage.getItem('autoPlayEnabled') === 'true';
      autoPlayToggle.checked = autoPlayEnabled;
    });
  </script>
</body>
</html> 